#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CyberThreatHunter - Web漏洞扫描模块
检测SQL注入、XSS、命令注入等常见Web漏洞
"""

import requests
import concurrent.futures
from typing import List, Dict, Any, Optional, Tuple
from urllib.parse import urljoin, urlparse, parse_qs, urlencode
import re
import time
import logging
import json


class VulnerabilityScanner:
    """Web漏洞扫描器"""
    
    def __init__(self, config: Dict[str, Any]):
        """
        初始化漏洞扫描器
        
        Args:
            config: 配置文件
        """
        self.config = config
        self.web_config = config.get("web", {})
        self.scan_config = config.get("scanning", {})
        self.logger = logging.getLogger("VulnScanner.VulnerabilityScanner")
        
        # 会话设置
        self.session = requests.Session()
        self.session.headers.update({
            "User-Agent": self.scan_config.get("user_agent", "VulnerabilityScanner/1.0"),
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.5",
            "Accept-Encoding": "gzip, deflate",
            "Connection": "close"
        })
        
        # 设置超时
        self.timeout = self.scan_config.get("timeout", 10)
        
        # 代理设置
        proxy = self.scan_config.get("proxy")
        if proxy:
            self.session.proxies = {"http": proxy, "https": proxy}
    
    def _extract_links(self, url: str) -> List[Dict[str, Any]]:
        """
        从页面提取链接和表单
        
        Args:
            url: 目标URL
            
        Returns:
            List[Dict]: 链接和表单信息
        """
        try:
            response = self.session.get(url, timeout=self.timeout)
            content = response.text
            
            links = []
            
            # 提取链接
            link_pattern = r'<a[^>]+href=["\']([^"\']+)["\'][^>]*>'
            for match in re.finditer(link_pattern, content, re.IGNORECASE):
                href = match.group(1)
                if href and not href.startswith(('javascript:', 'mailto:', 'tel:', '#')):
                    full_url = urljoin(url, href)
                    links.append({
                        "type": "link",
                        "url": full_url,
                        "method": "GET"
                    })
            
            # 提取表单
            form_pattern = r'<form[^>]+action=["\']([^"\']+)["\'][^>]*method=["\']([^"\']+)["\'][^>]*>'
            for match in re.finditer(form_pattern, content, re.IGNORECASE):
                action = match.group(1)
                method = match.group(2).upper()
                full_url = urljoin(url, action)
                links.append({
                    "type": "form",
                    "url": full_url,
                    "method": method
                })
            
            # 提取输入参数
            input_pattern = r'<input[^>]+name=["\']([^"\']+)["\'][^>]*>'
            input_names = re.findall(input_pattern, content, re.IGNORECASE)
            
            self.logger.info(f"从 {url} 提取到 {len(links)} 个链接，{len(input_names)} 个输入字段")
            
            return links
            
        except Exception as e:
            self.logger.error(f"提取链接失败: {e}")
            return []
    
    def _test_sql_injection(self, url: str, method: str = "GET", 
                           params: Dict[str, str] = None) -> List[Dict[str, Any]]:
        """
        测试SQL注入漏洞
        
        Args:
            url: 目标URL
            method: HTTP方法
            params: 参数
            
        Returns:
            List[Dict]: 发现的漏洞
        """
        payloads = self.web_config.get("sql_payloads", [
            "'", "\"", "1' OR '1'='1", "1' OR '1'='1'--", "1' OR '1'='1'#",
            "' OR '1'='1", "' OR '1'='1'--", "' OR '1'='1'#",
            "1' AND '1'='2", "1' AND sleep(5)--", "' AND sleep(5)--"
        ])
        
        findings = []
        
        try:
            # 解析URL获取参数
            parsed_url = urlparse(url)
            query_params = parse_qs(parsed_url.query)
            
            # 如果没有参数，尝试使用提供的参数
            if not query_params and params:
                query_params = {k: [v] for k, v in params.items()}
            
            if not query_params:
                return findings
            
            for param_name in list(query_params.keys()):
                original_value = query_params[param_name][0]
                
                for payload in payloads:
                    # 构建测试参数
                    test_params = query_params.copy()
                    test_params[param_name] = [payload]
                    
                    # 构建测试URL
                    if method.upper() == "GET":
                        test_query = urlencode(test_params, doseq=True)
                        test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{test_query}"
                        
                        try:
                            response = self.session.get(test_url, timeout=self.timeout)
                            
                            # 检测SQL注入迹象
                            error_patterns = [
                                r"SQL syntax.*MySQL",
                                r"Warning.*mysql_.*",
                                r"MySQLSyntaxErrorException",
                                r"valid MySQL result",
                                r"PostgreSQL.*ERROR",
                                r"Warning.*\Wpg_.*",
                                r"valid PostgreSQL result",
                                r"SQLite/JDBCDriver",
                                r"System.Data.SQLite.SQLiteException",
                                r"Warning.*sqlite_.*",
                                r"valid SQLite result",
                                r"ORA-[0-9]{5}",
                                r"Oracle error",
                                r"Oracle.*Driver",
                                r"Microsoft SQL Server",
                                r"Driver.*SQL Server",
                                r"SQLServer JDBC Driver",
                                r"macromedia.jdbc.sqlserver",
                                r"com.informix.jdbc",
                                r"Syntax error in string in query expression",
                                r"Unclosed quotation mark",
                                r"You have an error in your SQL syntax"
                            ]
                            
                            content = response.text
                            for pattern in error_patterns:
                                if re.search(pattern, content, re.IGNORECASE):
                                    finding = self._create_sql_finding(
                                        url=url,
                                        param_name=param_name,
                                        payload=payload,
                                        evidence=response.text[:500],
                                        response_code=response.status_code
                                    )
                                    findings.append(finding)
                                    break
                            
                        except Exception as e:
                            self.logger.debug(f"SQL注入测试失败: {e}")
                    
                    elif method.upper() == "POST":
                        # POST请求测试
                        data = {k: v[0] for k, v in test_params.items()}
                        
                        try:
                            response = self.session.post(url, data=data, timeout=self.timeout)
                            
                            content = response.text
                            error_patterns = [
                                r"SQL syntax.*MySQL",
                                r"Unclosed quotation mark",
                                r"You have an error in your SQL syntax"
                            ]
                            
                            for pattern in error_patterns:
                                if re.search(pattern, content, re.IGNORECASE):
                                    finding = self._create_sql_finding(
                                        url=url,
                                        param_name=param_name,
                                        payload=payload,
                                        evidence=response.text[:500],
                                        response_code=response.status_code
                                    )
                                    findings.append(finding)
                                    break
                            
                        except Exception as e:
                            self.logger.debug(f"SQL注入测试失败: {e}")
        
        except Exception as e:
            self.logger.error(f"SQL注入测试过程中发生错误: {e}")
        
        return findings
    
    def _create_sql_finding(self, url: str, param_name: str, payload: str,
                           evidence: str, response_code: int) -> Dict[str, Any]:
        """创建SQL注入发现项"""
        finding = {
            "type": "sql_injection",
            "name": "SQL注入漏洞",
            "description": f"在参数 '{param_name}' 中发现SQL注入漏洞",
            "severity": "critical",
            "cvss_score": 9.0,
            "evidence": f"URL: {url}, 参数: {param_name}, 载荷: {payload}, 响应码: {response_code}",
            "remediation": "使用参数化查询或预编译语句，对用户输入进行严格验证和过滤",
            "details": {
                "target": url,
                "vulnerability_type": "sql_injection",
                "parameter": param_name,
                "payload": payload,
                "evidence": evidence,
                "response_code": response_code,
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")
            }
        }
        return finding
    
    def _test_xss(self, url: str, method: str = "GET", 
                 params: Dict[str, str] = None) -> List[Dict[str, Any]]:
        """
        测试XSS漏洞
        
        Args:
            url: 目标URL
            method: HTTP方法
            params: 参数
            
        Returns:
            List[Dict]: 发现的漏洞
        """
        payloads = self.web_config.get("xss_payloads", [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert(1)>",
            "\" onmouseover=\"alert(1)",
            "' onmouseover='alert(1)'",
            "<svg onload=alert(1)>",
            "javascript:alert(1)",
            "data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="
        ])
        
        findings = []
        
        try:
            parsed_url = urlparse(url)
            query_params = parse_qs(parsed_url.query)
            
            if not query_params and params:
                query_params = {k: [v] for k, v in params.items()}
            
            if not query_params:
                return findings
            
            for param_name in list(query_params.keys()):
                for payload in payloads:
                    test_params = query_params.copy()
                    test_params[param_name] = [payload]
                    
                    if method.upper() == "GET":
                        test_query = urlencode(test_params, doseq=True)
                        test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{test_query}"
                        
                        try:
                            response = self.session.get(test_url, timeout=self.timeout)
                            content = response.text
                            
                            # 检查载荷是否出现在响应中
                            if payload in content:
                                finding = self._create_xss_finding(
                                    url=url,
                                    param_name=param_name,
                                    payload=payload,
                                    evidence=response.text[:500],
                                    response_code=response.status_code
                                )
                                findings.append(finding)
                                
                        except Exception as e:
                            self.logger.debug(f"XSS测试失败: {e}")
                    
                    elif method.upper() == "POST":
                        data = {k: v[0] for k, v in test_params.items()}
                        
                        try:
                            response = self.session.post(url, data=data, timeout=self.timeout)
                            content = response.text
                            
                            if payload in content:
                                finding = self._create_xss_finding(
                                    url=url,
                                    param_name=param_name,
                                    payload=payload,
                                    evidence=response.text[:500],
                                    response_code=response.status_code
                                )
                                findings.append(finding)
                                
                        except Exception as e:
                            self.logger.debug(f"XSS测试失败: {e}")
        
        except Exception as e:
            self.logger.error(f"XSS测试过程中发生错误: {e}")
        
        return findings
    
    def _create_xss_finding(self, url: str, param_name: str, payload: str,
                           evidence: str, response_code: int) -> Dict[str, Any]:
        """创建XSS发现项"""
        finding = {
            "type": "xss",
            "name": "跨站脚本(XSS)漏洞",
            "description": f"在参数 '{param_name}' 中发现反射型XSS漏洞",
            "severity": "high",
            "cvss_score": 7.0,
            "evidence": f"URL: {url}, 参数: {param_name}, 载荷: {payload}, 响应码: {response_code}",
            "remediation": "对所有用户输入进行HTML编码，使用内容安全策略(CSP)，设置HttpOnly标志",
            "details": {
                "target": url,
                "vulnerability_type": "xss",
                "parameter": param_name,
                "payload": payload,
                "evidence": evidence,
                "response_code": response_code,
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")
            }
        }
        return finding
    
    def _test_command_injection(self, url: str, method: str = "GET",
                               params: Dict[str, str] = None) -> List[Dict[str, Any]]:
        """
        测试命令注入漏洞
        
        Args:
            url: 目标URL
            method: HTTP方法
            params: 参数
            
        Returns:
            List[Dict]: 发现的漏洞
        """
        payloads = self.web_config.get("cmd_payloads", [
            ";ls", "|ls", "`ls`", "$(ls)", "|| ls", "&& ls",
            ";id", "|id", "`id`", "$(id)", "|| id", "&& id",
            ";cat /etc/passwd", "|cat /etc/passwd",
            "`cat /etc/passwd`", "$(cat /etc/passwd)"
        ])
        
        findings = []
        
        try:
            parsed_url = urlparse(url)
            query_params = parse_qs(parsed_url.query)
            
            if not query_params and params:
                query_params = {k: [v] for k, v in params.items()}
            
            if not query_params:
                return findings
            
            for param_name in list(query_params.keys()):
                for payload in payloads:
                    test_params = query_params.copy()
                    test_params[param_name] = [payload]
                    
                    if method.upper() == "GET":
                        test_query = urlencode(test_params, doseq=True)
                        test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{test_query}"
                        
                        try:
                            start_time = time.time()
                            response = self.session.get(test_url, timeout=self.timeout)
                            elapsed_time = time.time() - start_time
                            
                            content = response.text
                            
                            # 检测命令注入迹象
                            indicators = [
                                r"root:.*:0:0:",
                                r"bin/.*sh",
                                r"Permission denied",
                                r"command not found",
                                r"uid=\d+\(.*\) gid=\d+\(.*\)"
                            ]
                            
                            for pattern in indicators:
                                if re.search(pattern, content, re.IGNORECASE):
                                    finding = self._create_cmd_finding(
                                        url=url,
                                        param_name=param_name,
                                        payload=payload,
                                        evidence=response.text[:500],
                                        response_code=response.status_code,
                                        response_time=elapsed_time
                                    )
                                    findings.append(finding)
                                    break
                                
                        except Exception as e:
                            self.logger.debug(f"命令注入测试失败: {e}")
        
        except Exception as e:
            self.logger.error(f"命令注入测试过程中发生错误: {e}")
        
        return findings
    
    def _create_cmd_finding(self, url: str, param_name: str, payload: str,
                           evidence: str, response_code: int, response_time: float) -> Dict[str, Any]:
        """创建命令注入发现项"""
        finding = {
            "type": "command_injection",
            "name": "命令注入漏洞",
            "description": f"在参数 '{param_name}' 中发现命令注入漏洞",
            "severity": "critical",
            "cvss_score": 9.5,
            "evidence": f"URL: {url}, 参数: {param_name}, 载荷: {payload}, 响应时间: {response_time:.2f}s",
            "remediation": "避免使用系统调用，使用安全的API，对用户输入进行严格验证，使用白名单过滤",
            "details": {
                "target": url,
                "vulnerability_type": "command_injection",
                "parameter": param_name,
                "payload": payload,
                "evidence": evidence,
                "response_code": response_code,
                "response_time": response_time,
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")
            }
        }
        return finding
    
    def _test_headers(self, url: str) -> List[Dict[str, Any]]:
        """
        测试HTTP安全头
        
        Args:
            url: 目标URL
            
        Returns:
            List[Dict]: 安全头问题
        """
        findings = []
        
        try:
            response = self.session.get(url, timeout=self.timeout)
            headers = response.headers
            
            # 检查缺少的安全头
            security_headers = {
                "X-Content-Type-Options": {
                    "expected": "nosniff",
                    "severity": "medium",
                    "description": "缺少X-Content-Type-Options头，可能导致MIME类型混淆攻击"
                },
                "X-Frame-Options": {
                    "expected": ["DENY", "SAMEORIGIN"],
                    "severity": "medium",
                    "description": "缺少X-Frame-Options头，可能导致点击劫持攻击"
                },
                "Content-Security-Policy": {
                    "expected": None,  # 任意值都行
                    "severity": "high",
                    "description": "缺少Content-Security-Policy头，无法有效防止XSS攻击"
                },
                "Strict-Transport-Security": {
                    "expected": None,
                    "severity": "high",
                    "description": "缺少HSTS头，可能导致SSL剥离攻击"
                }
            }
            
            for header, config in security_headers.items():
                if header not in headers:
                    finding = self._create_header_finding(
                        url=url,
                        header=header,
                        issue="missing",
                        description=config["description"],
                        severity=config["severity"]
                    )
                    findings.append(finding)
                else:
                    # 检查头值是否安全
                    if header == "X-Content-Type-Options":
                        if headers[header].lower() != "nosniff":
                            finding = self._create_header_finding(
                                url=url,
                                header=header,
                                issue="misconfigured",
                                description=f"X-Content-Type-Options值不安全: {headers[header]}",
                                severity="medium"
                            )
                            findings.append(finding)
                    
                    elif header == "X-Frame-Options":
                        if headers[header].upper() not in ["DENY", "SAMEORIGIN"]:
                            finding = self._create_header_finding(
                                url=url,
                                header=header,
                                issue="misconfigured",
                                description=f"X-Frame-Options值不安全: {headers[header]}",
                                severity="medium"
                            )
                            findings.append(finding)
        
        except Exception as e:
            self.logger.error(f"安全头检查失败: {e}")
        
        return findings
    
    def _create_header_finding(self, url: str, header: str, issue: str,
                              description: str, severity: str) -> Dict[str, Any]:
        """创建安全头发现项"""
        cvss_scores = {
            "critical": 9.0,
            "high": 7.0,
            "medium": 4.0,
            "low": 2.0
        }
        
        finding = {
            "type": "security_header",
            "name": f"HTTP安全头问题: {header}",
            "description": description,
            "severity": severity,
            "cvss_score": cvss_scores.get(severity, 0.0),
            "evidence": f"URL: {url}, 头: {header}, 问题: {issue}",
            "remediation": "配置适当的安全HTTP头",
            "details": {
                "target": url,
                "header": header,
                "issue": issue,
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")
            }
        }
        return finding
    
    def scan(self, target: str) -> List[Dict[str, Any]]:
        """
        执行Web漏洞扫描
        
        Args:
            target: 目标URL
            
        Returns:
            List[Dict]: 扫描结果
        """
        self.logger.info(f"开始Web漏洞扫描: {target}")
        
        # 确保URL格式正确
        if not target.startswith(('http://', 'https://')):
            target = f"http://{target}"
        
        findings = []
        
        try:
            # 测试目标可访问性
            test_response = self.session.get(target, timeout=self.timeout)
            if test_response.status_code not in [200, 301, 302]:
                self.logger.warning(f"目标 {target} 不可访问，状态码: {test_response.status_code}")
                return findings
            
            self.logger.info(f"目标 {target} 可访问，开始漏洞扫描...")
            
            # 提取链接和表单
            links = self._extract_links(target)
            
            # 并发测试所有链接
            max_workers = self.scan_config.get("threads", 20)
            
            with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
                # 提交所有测试任务
                future_tasks = []
                
                for link in links[:10]:  # 限制测试数量
                    url = link["url"]
                    method = link["method"]
                    
                    # SQL注入测试
                    future_tasks.append(executor.submit(self._test_sql_injection, url, method))
                    
                    # XSS测试
                    future_tasks.append(executor.submit(self._test_xss, url, method))
                    
                    # 命令注入测试
                    future_tasks.append(executor.submit(self._test_command_injection, url, method))
                
                # 安全头测试
                future_tasks.append(executor.submit(self._test_headers, target))
                
                # 收集结果
                for future in concurrent.futures.as_completed(future_tasks):
                    try:
                        result = future.result(timeout=self.timeout * 2)
                        findings.extend(result)
                    except Exception as e:
                        self.logger.debug(f"漏洞测试失败: {e}")
            
            # 去重
            unique_findings = []
            seen_evidences = set()
            
            for finding in findings:
                evidence = finding.get("evidence", "")
                if evidence not in seen_evidences:
                    seen_evidences.add(evidence)
                    unique_findings.append(finding)
            
            findings = unique_findings
            
        except Exception as e:
            self.logger.error(f"Web漏洞扫描失败: {e}")
        
        self.logger.info(f"Web漏洞扫描完成，发现 {len(findings)} 个漏洞")
        return findings


def main():
    """测试函数"""
    import sys
    
    if len(sys.argv) < 2:
        print("用法: python vulnerability_scanner.py <目标URL>")
        print("示例: python vulnerability_scanner.py http://example.com")
        sys.exit(1)
    
    target = sys.argv[1]
    
    # 创建配置
    config = {
        "web": {
            "sql_payloads": ["'", "1' OR '1'='1"],
            "xss_payloads": ["<script>alert('XSS')</script>"],
            "cmd_payloads": [";ls"]
        },
        "scanning": {
            "timeout": 10,
            "threads": 10,
            "user_agent": "VulnerabilityScanner/1.0"
        }
    }
    
    # 设置日志
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    
    scanner = VulnerabilityScanner(config)
    findings = scanner.scan(target)
    
    print(f"\nWeb漏洞扫描结果 ({target}):")
    print("=" * 80)
    
    if findings:
        for finding in findings:
            print(f"漏洞类型: {finding['type']}")
            print(f"风险等级: {finding['severity']}")
            print(f"描述: {finding['description']}")
            print(f"证据: {finding['evidence'][:100]}...")
            print("-" * 80)
    else:
        print("未发现Web漏洞")
    
    print(f"总计发现: {len(findings)} 个漏洞")


if __name__ == "__main__":
    main()